; ABNF is not a good fit because it builds parsers, and ALACS is shy of that

; input is UTF-8 encoded, rules work on the bytes without decoding them.
; INDENT and DEDENT can't be defined here, those TAB chars are not covered here.

LF = %x0A
dot = %x00-09 / %x0B-FF
line = *dot LF

; byte not in marker set: excludes TAB(09) #(23) /(2F) <(3C) =(3D) >(3E) [(5B) ](5D) {(7B) }(7D)
plain = %x00-08 / %x0B-22 / %x24-2E / %x30-3B / %x3F-5A / %x5C / %x5E-7A / %x7C / %x7E-FF

; short key cannot start with marker, cannot contain LF or "="
shortkey = plain *(%x00-08 / %x0B-3C / %x3E-FF)

; long key can contain anything except LF (delimiters handle the rest)
longkey = *dot

utf8 = INDENT *line DEDENT

comment = "#" line [utf8]

; linear array element alternatives
list-text = "<>" [utf8] [comment]
list-array = "[]" [INDENT [comment] *list-item DEDENT] [comment]
list-dict = "{}" [INDENT [comment] *dict-entry DEDENT] [comment]
list-empty = [comment]
list-short = plain *dot LF [comment]

list-item = list-text / list-array / list-dict / list-empty / list-short

; common prefix for associative array entries
; at most one blank line, must precede key comment if present
key-prolog = [LF] ["//" line [utf8]]

; associative array entry alternatives
dict-text = key-prolog "<" longkey ">" [utf8] [comment]
dict-array = key-prolog "[" longkey "]" [INDENT [comment] *list-item DEDENT] [comment]
dict-dict = key-prolog "{" longkey "}" [INDENT [comment] *dict-entry DEDENT] [comment]
dict-short = key-prolog shortkey "=" line [comment]

dict-entry = dict-text / dict-array / dict-dict / dict-short

; top level is an implicit associative array with optional hashbang
hashbang = "#!" line [utf8]
file = [hashbang] [comment] *dict-entry
